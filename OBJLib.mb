'*******************************************************************************
'** 	Program:
'** 	Modul:
'**
'*******************************************************************************

'-------------------------------------
Include "MapBasic.def"
Include "Icons.def"
Include "Menu.def"
'**default constants...
Include "Defaults.def"

'-------------------------------------
Include "DEBUGLib.def"
Include "ERRORLib.def"
Include "MATHLib.def"
Include "OBJLib.def"
Include "TABLELib.def"

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJIsInitialized(ByVal oObj As Object) As Logical

Dim	nType As Integer

OnError GoTo ErrorOccured

OBJIsInitialized = FALSE

	OnError GoTo NotInitialized
	nType = ObjectInfo(oObj, OBJ_INFO_TYPE)

OBJIsInitialized = TRUE

	Exit Function
'-------------------------
NotInitialized:
	OBJIsInitialized = FALSE

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJIsInitialized")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJFindNode(	  ByVal oObj As Object		'The object (polyline or polygon) to search in, only the first segment of the object will be searched
					, ByVal oNode As Object		'Node position to look for
					, ByVal fTolerance As Float	'Search tolerance, in meters, distance is measured using Cartesian calculation
					) As Integer				'Returns the first matching node number, or 0 if no found

Dim	nSegm, nNode As Integer

OnError GoTo ErrorOccured

OBJFindNode = 0

	If OBJFindSegmentAndNode(oObj, oNode, fTolerance, nSegm, nNode) Then
		If nSegm = 1 Then
			OBJFindNode = nNode
		End If
	End If

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJFindNode")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJFindSegmentAndNode( ByVal oObj As Object		'The object (polyline or polygon) to search in
						, ByVal oNode As Object		'Node position to look for
						, ByVal fTolerance As Float	'Search tolerance, in meters, distance is measured using Cartesian calculation
						, nSegmentFound As Integer	'The Segment number where the node was found
						, nNodeFound As Integer		'The matching node number
						) As Logical				'Returns TRUE if a matching node was found, otherwise FALSE

Dim	nSegm, nNode As Integer,
	fNodeX, fNodeY, fX, fY, fDistance As Float

OnError GoTo ErrorOccured

OBJFindSegmentAndNode = FALSE

	If NOT ObjectInfo(oObj, OBJ_INFO_TYPE) IN (OBJ_TYPE_PLINE, OBJ_TYPE_REGION) Then
		Exit Function
	End If

	fNodeX	= CentroidX(oNode)
	fNodeY	= CentroidY(oNode)

	For nSegm = 1 To ObjectInfo(oObj, OBJ_INFO_NPOLYGONS)
		For nNode = 1 To ObjectInfo(oObj, OBJ_INFO_NPOLYGONS + nSegm)
			fX	= ObjectNodeX(oObj, nSegm, nNode)
			fY	= ObjectNodeY(oObj, nSegm, nNode)

			fDistance	= CartesianDistance(fNodeX, fNodeY, fX, fY, "m")
			If fDistance <= fTolerance Then
'				Call DEBUGPrint("   Found node as no " & nNode & " " & fDistance & " m from point")
				nSegmentFound	= nSegm
				nNodeFound	= nNode
				OBJFindSegmentAndNode = TRUE
				Exit Function
			End If
		Next		'nNode
	Next		'nSegm

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJFindSegmentAndNode")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJFindNodeBinary(	  ByVal oObj As Object		'The object (polyline or polygon) to search in, only the first segment of the object will be searched
						, ByVal oNode As Object		'Node position to look for
						, ByVal fTolerance As Float	'Search tolerance, in meters, distance is measured using Cartesian calculation
						, ByVal nOffset As Integer	'Offset of 1st node in polyline based on original, use 0 for first call
						) As Integer				'Returns the first matching node number, or 0 if no found

Dim	objLow, objHigh As Object,
	nPnts, nNode, nMid As Integer

OnError GoTo ErrorOccured

OBJFindNodeBinary = 0

	nPnts = ObjectInfo(oObj, OBJ_INFO_NPNTS)

	If nPnts < 100 Then
'		Call DEBUGPrint("   Searching using OBJFindNode (" & nPnts & " points)")
		nNode = OBJFindNode( oObj, oNode, fTolerance)
		If nNode > 0 Then
			OBJFindNodeBinary = (nNode + nOffset)
		End If
		Exit Function
	End If

	' Determine the middle point
	nMid = nPnts \ 2 + nPnts Mod 2
'	Call DEBUGPrint("   Mid: " & nMid & " out of " & nPnts & " points. Offset = " & nOffset)

	' Start with the lower half
	objLow = ExtractNodes( oObj, 1, 1, nMid, FALSE)
	If oNode Within CartesianBuffer(MBR(objLow), 25, fTolerance, "m") Then
'		Call DEBUGPrint("   Searching in lower part: 1 - " & nMid )
		nNode = OBJFindNodeBinary(objLow, oNode, fTolerance, nOffset)
		OBJFindNodeBinary = nNode
	Else
		' Forget this branch
		nNode = 0
	End If

	' If we couldn't find it in the lower, then check the upper half
	If nNode = 0 Then
		objHigh = ExtractNodes(oObj, 1, nMid + 1, nPnts, FALSE )
		If oNode Within CartesianBuffer(MBR(objHigh), 25, fTolerance, "m") Then
'			Call DEBUGPrint("   Searching in higher part: " & (nMid + 1) & " - " & nPnts)
			nNode = OBJFindNodeBinary( objHigh, oNode, fTolerance, nOffset + nMid)
		Else
			' Forget this branch
			nNode = 0
		End If
	End If

	OBJFindNodeBinary = nNode

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJFindNodeBinary: nNode: " & nNode)
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJRemoveDuplicateNodes(	  ByVal oObj As Object		'The object (polyline or polygon) to remove duplicate nodes in
							, ByVal fTolerance As Float	'The tolerance defining whether two nodes are "the same", distance is measured using Cartesian calculation
							) As Object				'Returns the object with duplicate nodes removed

Dim	nSegm, nNode, nNumNodes As Integer,
	fPrevX, fPrevY, fX, fY As Float

OnError GoTo ErrorOccured

OBJRemoveDuplicateNodes = oObj

	If NOT ObjectInfo(oObj, OBJ_INFO_TYPE) IN (OBJ_TYPE_PLINE, OBJ_TYPE_REGION) Then
		Exit Function
	End If

'	Call DEBUGPrint("OBJRemoveDuplicateNodes")
	For nSegm = 1 To ObjectInfo(oObj, OBJ_INFO_NPOLYGONS)
'		Call DEBUGPrint("   Segment: " & nSegm)

		nNumNodes	= ObjectInfo(oObj, OBJ_INFO_NPOLYGONS + nSegm)
		fPrevX	= ObjectNodeX(oObj, nSegm, nNumNodes)
		fPrevY	= ObjectNodeY(oObj, nSegm, nNumNodes)

		For nNode = (nNumNodes - 1) To 1 Step -1
'			Call DEBUGPrint("      Node: " & nNode)
			fX	= ObjectNodeX(oObj, nSegm, nNode)
			fY	= ObjectNodeY(oObj, nSegm, nNode)

			If CartesianDistance(fPrevX, fPrevY, fX, fY, "m") <= fTolerance Then
				If nNode = 1 Then
					Call DEBUGPrint("      - Node 1 on segment " & nSegm)
'					Alter Object oObj
'						Node Remove Position nSegm, 2
				Else
					Call DEBUGPrint("      - Removing Node " & nNode & " from segment " & nSegm)
					Alter Object oObj
						Node Remove Position nSegm, nNode
				End If
			Else
				fPrevX	= fX
				fPrevY	= fY
			End If
		Next		'nNode
	Next		'nSegm

OBJRemoveDuplicateNodes = oObj

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJRemoveDuplicateNodes")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJReverse(  ByVal oObj As Object			'The object which node order to reverse, only line, polyline and polygons are supported
				) As Object					'Returns the object with the nodes in reversed order

OnError GoTo ErrorOccured

	Do Case ObjectInfo(oObj, OBJ_INFO_TYPE)
		Case OBJ_TYPE_LINE
			OBJReverse = OBJReverseLine(oObj)
		Case OBJ_TYPE_PLINE
			OBJReverse = OBJReversePolyline(oObj)
		Case Else
			OBJReverse = oObj
	End Case

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJReverse")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJReversePolyline(  ByVal oObj As Object		'The polyline which node order to reverse, only is supported
							) As Object			'Returns the polyline with the nodes in reversed order

Dim	nSegm, nNode As Integer,
	fX, fY As Float,
	oNew As object

OnError GoTo ErrorOccured

OBJReversePolyline = oObj

	Create Pline
		Into Variable oNew
		'[ Multiple num_sections ]
		0	'num_points ( x1, y1 ) ( x2, y2 ) [ ... ]
		Pen ObjectInfo(oObj, OBJ_INFO_PEN)


	For nSegm = 1 To ObjectInfo(oObj, OBJ_INFO_NPOLYGONS)
		For nNode = 1 To ObjectInfo(oObj, OBJ_INFO_NPOLYGONS + nSegm)
			fX	= ObjectNodeX(oObj, nSegm, nNode)
			fY	= ObjectNodeY(oObj, nSegm, nNode)

			Alter Object oNew
				Node Add Position nSegm, 1 ( fX, fY )
		Next		'nNode
	Next		'nSegm

OBJReversePolyline = oNew

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJReversePolyline")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJReverseLine(	  ByVal oObj As Object		'The line which node order to reverse, only line is supported
					) As Object				'Returns the line with the nodes in reversed order

Dim	oNew As Object

OnError GoTo ErrorOccured

	Create Line
		Into Variable oNew
		( ObjectGeography(oObj, OBJ_GEO_LINEENDX), ObjectGeography(oObj, OBJ_GEO_LINEENDY))
		( ObjectGeography(oObj, OBJ_GEO_LINEBEGX), ObjectGeography(oObj, OBJ_GEO_LINEBEGY))
		Pen ObjectInfo(oObj, OBJ_INFO_PEN)

	OBJReverseLine = oNew

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJReverseLine")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJAreTouchingAtEndNodes(	  ByVal oFirst As Object		'The first object to use
							, ByVal oSecond As Object	'The second object to use
							, ByVal fTolerance As Float	'The tolerance distance allowed
							) As Logical				'Returns true if the distance between two end nodes are less than fTolereance

Dim	fAX1, fAY1, fAX2, fAY2, fBX1, fBY1, fBX2, fBY2 As Float,
	arrDistance(4) As Float,
	nSegments, i, nMinimum As Integer

OnError GoTo ErrorOccured

OBJAreTouchingAtEndNodes = FALSE

	fAX1		= ObjectNodeX(oFirst, 1, 1)
	fAY1		= ObjectNodeY(oFirst, 1, 1)
	nSegments	= ObjectInfo(oFirst, OBJ_INFO_NPOLYGONS)
	fAX2		= ObjectNodeX(oFirst, nSegments, ObjectInfo(oFirst, OBJ_INFO_NPOLYGONS + nSegments))
	fAY2 	= ObjectNodeY(oFirst, nSegments, ObjectInfo(oFirst, OBJ_INFO_NPOLYGONS + nSegments))

	fBX1		= ObjectNodeX(oSecond, 1, 1)
	fBY1		= ObjectNodeY(oSecond, 1, 1)
	nSegments	= ObjectInfo(oSecond, OBJ_INFO_NPOLYGONS)
	fBX2		= ObjectNodeX(oSecond, nSegments, ObjectInfo(oSecond, OBJ_INFO_NPOLYGONS + nSegments))
	fBY2		= ObjectNodeY(oSecond, nSegments, ObjectInfo(oSecond, OBJ_INFO_NPOLYGONS + nSegments))

	arrDistance(1)	= Distance(fAX1, fAY1, fBX1, fBY1, "m")
	arrDistance(2)	= Distance(fAX1, fAY1, fBX2, fBY2, "m")
	arrDistance(3)	= Distance(fAX2, fAY2, fBX1, fBY1, "m")
	arrDistance(4)	= Distance(fAX2, fAY2, fBX2, fBY2, "m")

	nMinimum	= 1
	For i = 2 To 4
'		Call DEBUGPrint("OBJAreTouchingAtEndNodes: " & arrDistance(nMinimum) & " > " & arrDistance(i))
		If arrDistance(nMinimum) > arrDistance(i) Then
			nMinimum	= i
'			Call DEBUGPrint("OBJAreTouchingAtEndNodes: Minimum: " & arrDistance(nMinimum))
		End If
	Next

'	Call DEBUGPrint("OBJAreTouchingAtEndNodes: Minimum: " & arrDistance(nMinimum))
	If arrDistance(nMinimum) <= fTolerance Then
		OBJAreTouchingAtEndNodes = TRUE
	End If

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJAreTouchingAtEndNodes")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJFindNearestEndNodes(	  ByVal oFirst As Object		'The first object to use
							, ByVal oSecond As Object	'The second object to use
							) As Integer				'Returns 1: First And First node, 2: First and Last, 3: Last and First, 4 Last and Last

Dim	fAX1, fAY1, fAX2, fAY2, fBX1, fBY1, fBX2, fBY2 As Float,
	arrDistance(4) As Float,
	nSegments, i, nMinimum As Integer

OnError GoTo ErrorOccured

OBJFindNearestEndNodes = FALSE

	fAX1		= ObjectNodeX(oFirst, 1, 1)
	fAY1		= ObjectNodeY(oFirst, 1, 1)
	nSegments	= ObjectInfo(oFirst, OBJ_INFO_NPOLYGONS)
	fAX2		= ObjectNodeX(oFirst, nSegments, ObjectInfo(oFirst, OBJ_INFO_NPOLYGONS + nSegments))
	fAY2 	= ObjectNodeY(oFirst, nSegments, ObjectInfo(oFirst, OBJ_INFO_NPOLYGONS + nSegments))

	fBX1		= ObjectNodeX(oSecond, 1, 1)
	fBY1		= ObjectNodeY(oSecond, 1, 1)
	nSegments	= ObjectInfo(oSecond, OBJ_INFO_NPOLYGONS)
	fBX2		= ObjectNodeX(oSecond, nSegments, ObjectInfo(oSecond, OBJ_INFO_NPOLYGONS + nSegments))
	fBY2		= ObjectNodeY(oSecond, nSegments, ObjectInfo(oSecond, OBJ_INFO_NPOLYGONS + nSegments))

	arrDistance(1)	= Distance(fAX1, fAY1, fBX1, fBY1, "m")
	arrDistance(2)	= Distance(fAX1, fAY1, fBX2, fBY2, "m")
	arrDistance(3)	= Distance(fAX2, fAY2, fBX1, fBY1, "m")
	arrDistance(4)	= Distance(fAX2, fAY2, fBX2, fBY2, "m")

	nMinimum	= 1
	For i = 2 To 4
'		Call DEBUGPrint("OBJFindNearestEndNodes: " & arrDistance(nMinimum) & " > " & arrDistance(i))
		If arrDistance(nMinimum) > arrDistance(i) Then
			nMinimum	= i
'			Call DEBUGPrint("OBJFindNearestEndNodes: Minimum: " & arrDistance(nMinimum))
		End If
	Next

'	Call DEBUGPrint("OBJFindNearestEndNodes: Minimum: " & arrDistance(nMinimum))
	OBJFindNearestEndNodes = nMinimum

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJFindNearestEndNodes")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJCombineAtEndNode(	  ByVal oFirst As Object			'The first object to use
						, ByVal oSecond As Object		'The second object to use
						) As Object					'Return the combined object where one of the end nodes of oSecond has been moved to the nearest end node of oFirst

Dim	nNearestNodes, nSegmA, nNodeA, nSegmB, nNodeB As Integer,
	sText1, sText2 As String

OnError GoTo ErrorOccured

OBJCombineAtEndNode = FALSE

	nNearestNodes	= OBJFindNearestEndNodes(oFirst, oSecond)
	Do Case nNearestNodes
		Case 1, 2
			nSegmA	= 1
			nNodeA	= 1
			sText2	= " to first node (" & nSegmA & ", " & nNodeA & ") of first object"
		Case 3, 4
			nSegmA	= ObjectInfo(oFirst, OBJ_INFO_NPOLYGONS)
			nNodeA	= ObjectInfo(oFirst, OBJ_INFO_NPOLYGONS + nSegmA)
			sText2	= " to last node (" & nSegmA & ", " & nNodeA & ")  of first object"
	End Case
	Do Case nNearestNodes
		Case 1, 3
			nSegmB	= 1
			nNodeB	= 1
			sText1	= "Moving first node (" & nSegmB & ", " & nNodeB & ") of second object "
		Case 2, 4
			nSegmB	= ObjectInfo(oSecond, OBJ_INFO_NPOLYGONS)
			nNodeB	= ObjectInfo(oSecond, OBJ_INFO_NPOLYGONS + nSegmB)
			sText1	= "Moving last node (" & nSegmB & ", " & nNodeB & ") of second object "
	End Case

'	Call DEBUGPrint("OBJCombineAtEndNode: " & sText1 & sText2 & " Distance, m: " & Distance(ObjectNodeX(oSecond, nSegmB, nNodeB), ObjectNodeY(oSecond, nSegmB, nNodeB), ObjectNodeX(oFirst, nSegmA, nNodeA), ObjectNodeY(oFirst, nSegmA, nNodeA), "m"))
	Alter Object oSecond
		Node Set Position nSegmB, nNodeB (ObjectNodeX(oFirst, nSegmA, nNodeA), ObjectNodeY(oFirst, nSegmA, nNodeA))

	OBJCombineAtEndNode = Combine(oFirst, oSecond)

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJCombineAtEndNode")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJCombineAtEndNodeNByN(	  ByVal oFirst As Object			'The first object to use
							, ByVal oSecond As Object		'The second object to use
							) As Object					'Return the combined object where one of the end nodes of oSecond has been moved to the nearest end node of oFirst

Dim	nNearestNodes, nSegmA, nNodeA, nSegmB, nNodeB As Integer,
	nNode, nStartNode, nEndNode, nNodeStep As Integer,
	sText1, sText2 As String

OnError GoTo ErrorOccured

OBJCombineAtEndNodeNByN = FALSE

	If ObjectInfo(oSecond, OBJ_INFO_NPOLYGONS) > 1 Then
'		Call DEBUGPrint("OBJCombineAtEndNodeNByN using OBJCombineAtEndNode as second object has several segments")
		OBJCombineAtEndNodeNByN	= OBJCombineAtEndNodeNByN(oFirst, oSecond)
		Exit Function
	End If

	nNearestNodes	= OBJFindNearestEndNodes(oFirst, oSecond)
	Do Case nNearestNodes
		Case 1, 2
			nSegmA	= 1
			nNodeA	= 1
			sText2	= " to first node (" & nSegmA & ", " & nNodeA & ") of first object"
		Case 3, 4
			nSegmA	= ObjectInfo(oFirst, OBJ_INFO_NPOLYGONS)
			nNodeA	= (ObjectInfo(oFirst, OBJ_INFO_NPOLYGONS + nSegmA) + 1)
			sText2	= " to last node (" & nSegmA & ", " & nNodeA & ")  of first object"
	End Case
	Do Case nNearestNodes
		Case 1, 3
			nSegmB		= 1
			nNodeB		= 1
			nStartNode 	= 2
			nEndNode 		= ObjectInfo(oSecond, OBJ_INFO_NPOLYGONS + nSegmB)
			nNodeStep		= 1
			sText1	= "Moving first node (" & nSegmB & ", " & nNodeB & ") of second object "
		Case 2, 4
			nSegmB		= ObjectInfo(oSecond, OBJ_INFO_NPOLYGONS)
			nNodeB		= ObjectInfo(oSecond, OBJ_INFO_NPOLYGONS + nSegmB)
			nStartNode 	= (ObjectInfo(oSecond, OBJ_INFO_NPOLYGONS + nSegmB) - 1)
			nEndNode 		= 1
			nNodeStep		= -1
			sText1	= "Moving last node (" & nSegmB & ", " & nNodeB & ") of second object "
	End Case

'	Call DEBUGPrint("For " & nNode & " = " & nStartNode & " To " & nEndNode & " Step " & nNodeStep)
	For nNode = nStartNode To nEndNode Step nNodeStep

'		Call DEBUGPrint("OBJCombineAtEndNodeNByN: Adding Node" & nNode & " at position " & nNodeA)
		Alter Object oFirst
			Node Add Position nSegmA, nNodeA (ObjectNodeX(oSecond, nSegmB, nNode), ObjectNodeY(oSecond, nSegmB, nNode))

		If nNodeA > 1 Then
			nNodeA	= nNodeA + 1
		End If
	Next

	OBJCombineAtEndNodeNByN = oFirst

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJCombineAtEndNodeNByN")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJAddNodeOnPolyline(  ByVal oPolyline As Object		'The polyline that should have the node added
						, ByVal oPoint As Object			'The Node Point to add
						, ByVal fTolerance As Float		'The tolerance distance, m, that determines if the node is on the line
						) As Object					'The polyline with the added node

Dim	nSegm, nNode As Integer,
	oSegment, oLine As Object,
	fDistance, fMinDistance As Float

OnError GoTo ErrorOccured

OBJAddNodeOnPolyline = oPolyline

	fMinDistance	= 1000000
	For nSegm = 1 To ObjectInfo(oPolyline, OBJ_INFO_NPOLYGONS)
		If Distance(CentroidX(oPoint), CentroidY(oPoint), ObjectNodeX(oPolyline, nSegm, 1), ObjectNodeY(oPolyline, nSegm, 1), "m") <= fTolerance Then
'			Call DEBUGPrint("Using existing node no 1")
			Exit Function
		End If

		For nNode = 1 To (ObjectInfo(oPolyline, OBJ_INFO_NPOLYGONS + nSegm) - 1)
			If Distance(CentroidX(oPoint), CentroidY(oPoint), ObjectNodeX(oPolyline, nSegm, (nNode + 1)), ObjectNodeY(oPolyline, nSegm, (nNode + 1)), "m") <= fTolerance Then
'				Call DEBUGPrint("Using existing node no " & nNode)
				Exit Function
			End If

			oSegment	= ExtractNodes(oPolyline, nSegm, nNode, (nNode + 1), FALSE)
'			oLine	= ConnectObjects(oSegment, oPoint, TRUE)
			fDistance	= CartesianObjectDistance(oSegment, oPoint, "m")

'			If ObjectLen(oLine, "m") <= fTolerance Then
			If fDistance <= fTolerance Then
				Alter Object oPolyline
					Node Add Position nSegm, (nNode + 1) (CentroidX(oPoint), CentroidY(oPoint))
'				Call DEBUGPrint("   Adding node as no " & (nNode + 1) & " " & fDistance & " m from polyline")
				OBJAddNodeOnPolyline = oPolyline
				Exit Function
			Else
				fMinDistance	= Minimum(fMinDistance, fDistance)
			End If

		Next		'nNode
	Next		'nSegm

'	Call DEBUGPrint("Not found on polyline. Minimum distance: " & FormatNumber$(fMinDistance))

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJAddNodeOnPolyline")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJDirection(	ByVal oInput As Object			'The object to calculate the direction off, only works with projected coordinate systems
					) As Float					'Direction of object, 360 degrees, East = 0, counter-clockwise, unsupported objects return -1

Dim	fStartX, fStartY, fEndX, fEndY As Float,
	fDirection, fCurDirection, fCurLength, fLength As Float,
	nSegm, nNode As Integer,
	symInput As Symbol

OnError GoTo ErrorOccured

OBJDirection = -1

	Do Case ObjectInfo(oInput, OBJ_INFO_TYPE)
		Case OBJ_TYPE_POINT
			symInput = ObjectInfo(oInput, OBJ_INFO_SYMBOL)
			If StyleAttr(symInput, SYMBOL_KIND) = SYMBOL_KIND_FONT Then
				fDirection = StyleAttr(symInput, SYMBOL_ANGLE)
			Else
				fDirection = -1
			End If

		Case OBJ_TYPE_TEXT
			fDirection = ObjectGeography(oInput, OBJ_GEO_TEXTANGLE)

		Case OBJ_TYPE_LINE
			fStartX	= ObjectGeography(oInput, OBJ_GEO_LINEBEGX)
			fStartY	= ObjectGeography(oInput, OBJ_GEO_LINEBEGY)
			fEndX	= ObjectGeography(oInput, OBJ_GEO_LINEENDX)
			fEndY	= ObjectGeography(oInput, OBJ_GEO_LINEENDY)
			'Print "MATHGetDirection( " & fStartX & ", " & fStartY & " | " & fEndX & ", " & fEndY & " )"
			fDirection = MATHGetDirection(fStartX, fStartY, fEndX, fEndY)

		Case OBJ_TYPE_COLLECTION, OBJ_TYPE_MPOINT
			fDirection = -1

		Case OBJ_TYPE_ARC
			fDirection = -1

		Case OBJ_TYPE_ELLIPSE, OBJ_TYPE_RECT, OBJ_TYPE_ROUNDRECT
			fDirection = -1

		Case OBJ_TYPE_PLINE
			If ObjectInfo(oInput, OBJ_INFO_NPOLYGONS) = 1 Then
				fStartX = ObjectNodeX(oInput, 1, 1)
				fStartY = ObjectNodeY(oInput, 1, 1)
				nNode = ObjectInfo(oInput, OBJ_INFO_NPOLYGONS + 1)
				If nNode > 1 Then
					fEndX 		= ObjectNodeX(oInput, 1, nNode)
					fEndY 		= ObjectNodeY(oInput, 1, nNode)
					fDirection 	= MATHGetDirection(fStartX, fStartY, fEndX, fEndY)
				Else
					fDirection = -1
				End If
			Else
				fDirection = -1
			End If

		Case OBJ_TYPE_REGION
			For nSegm = 1 To ObjectInfo(oInput, OBJ_INFO_NPOLYGONS)
				fStartX = ObjectNodeX(oInput, nSegm, 1)
				fStartY = ObjectNodeY(oInput, nSegm, 1)
				For nNode = 2 To ObjectInfo(oInput, OBJ_INFO_NPOLYGONS + nSegm)
					fEndX 		= ObjectNodeX(oInput, nSegm, nNode)
					fEndY 		= ObjectNodeY(oInput, nSegm, nNode)
					fCurLength	= Distance(fStartX, fStartY, fEndX, fEndY, "m")

					If fCurLength > 0 Then
						If fStartX > fEndX Then
							If fStartY > fEndY Then
								fCurDirection 	= MATHGetDirection(fEndX, fEndY, fStartX, fStartY)
							Else
								fCurDirection 	= MATHGetDirection(fStartX, fStartY, fEndX, fEndY)
							End If
						ElseIf fStartY > fEndY Then
							If fStartX < fEndX Then
								fCurDirection 	= MATHGetDirection(fEndX, fEndY, fStartX, fStartY)
							Else
								fCurDirection 	= MATHGetDirection(fStartX, fStartY, fEndX, fEndY)
							End If
						Else
							fCurDirection 	= MATHGetDirection(fStartX, fStartY, fEndX, fEndY)
						End If

						Print nSegm & " " & nNode & ", Direction: " & FormatNumber$(Round(fCurDirection, 0.01)) & ", Length: " & FormatNumber$(Round(fCurLength, 0.01)) & " Weight: " & FormatNumber$(Round(fCurLength / (fLength + fCurLength), 0.01))
						Print "   Total " & ", Direction: " & FormatNumber$(Round(fDirection, 0.01)) & ", Length: " & FormatNumber$(Round(fLength, 0.01)) & " Weight: " & FormatNumber$(Round(fLength / (fLength + fCurLength), 0.01))
						fDirection	= (fCurDirection * (fCurLength / (fLength + fCurLength))) + (fDirection * (fLength / (fLength + fCurLength)))
					End If

					fLength = fLength + fCurLength
					fStartX = fEndX
					fStartY = fEndY
				Next	'nNode
			Next	'nSegm

		Case Else
			fDirection = -1
	End Case

	OBJDirection = fDirection

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJDirection")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJDirectionWtAvg(	  ByVal oInput As Object			'The object to calculate the direction off, only works with projected coordinate systems
						) As Float					'Direction of object, 360 degrees, East = 0, counter-clockwise, unsupported objects return -1

Dim	fStartX, fStartY, fEndX, fEndY As Float,
	fDirection, fCurDirection, fCurLength, fLength As Float,
	nSegm, nNode As Integer,
	symInput As Symbol

OnError GoTo ErrorOccured

OBJDirectionWtAvg = -1

	Do Case ObjectInfo(oInput, OBJ_INFO_TYPE)

		Case OBJ_TYPE_TEXT
			fDirection = -1

		Case OBJ_TYPE_LINE, OBJ_TYPE_ARC
			fDirection = OBJDirectionWtAvg(ConvertToPline(oInput))

		Case OBJ_TYPE_COLLECTION, OBJ_TYPE_MPOINT
			fDirection = -1

		Case OBJ_TYPE_ELLIPSE, OBJ_TYPE_RECT, OBJ_TYPE_ROUNDRECT
			fDirection = OBJDirectionWtAvg(ConvertToRegion(oInput))

		Case OBJ_TYPE_PLINE, OBJ_TYPE_REGION

			For nSegm = 1 To ObjectInfo(oInput, OBJ_INFO_NPOLYGONS)
				fStartX = ObjectNodeX(oInput, nSegm, 1)
				fStartY = ObjectNodeY(oInput, nSegm, 1)
				For nNode = 2 To ObjectInfo(oInput, OBJ_INFO_NPOLYGONS + nSegm)
					fEndX 		= ObjectNodeX(oInput, nSegm, nNode)
					fEndY 		= ObjectNodeY(oInput, nSegm, nNode)
					fCurLength	= Distance(fStartX, fStartY, fEndX, fEndY, "m")

					If fCurLength > 0 Then
						If fStartX > fEndX Then
							If fStartY > fEndY Then
								fCurDirection 	= MATHGetDirection(fEndX, fEndY, fStartX, fStartY)
							Else
								fCurDirection 	= MATHGetDirection(fStartX, fStartY, fEndX, fEndY)
							End If
						ElseIf fStartY > fEndY Then
							If fStartX < fEndX Then
								fCurDirection 	= MATHGetDirection(fEndX, fEndY, fStartX, fStartY)
							Else
								fCurDirection 	= MATHGetDirection(fStartX, fStartY, fEndX, fEndY)
							End If
						Else
							fCurDirection 	= MATHGetDirection(fStartX, fStartY, fEndX, fEndY)
						End If

						Print nSegm & " " & nNode & ", Direction: " & FormatNumber$(Round(fCurDirection, 0.01)) & ", Length: " & FormatNumber$(Round(fCurLength, 0.01)) & " Weight: " & FormatNumber$(Round(fCurLength / (fLength + fCurLength), 0.01))
						Print "   Total " & ", Direction: " & FormatNumber$(Round(fDirection, 0.01)) & ", Length: " & FormatNumber$(Round(fLength, 0.01)) & " Weight: " & FormatNumber$(Round(fLength / (fLength + fCurLength), 0.01))
						fDirection	= (fCurDirection * (fCurLength / (fLength + fCurLength))) + (fDirection * (fLength / (fLength + fCurLength)))
					End If

					fLength = fLength + fCurLength
					fStartX = fEndX
					fStartY = fEndY
				Next	'nNode
			Next	'nSegm

		Case Else
			fDirection = -1
	End Case

	OBJDirectionWtAvg = fDirection

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJDirectionWtAvg")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJDirectionMedian(	  ByVal oInput As Object			'The object to calculate the direction off, only works with projected coordinate systems
						) As Float					'Direction of object, 360 degrees, East = 0, counter-clockwise, unsupported objects return -1

Dim	fStartX, fStartY, fEndX, fEndY As Float,
	fDirection, fCurDirection, fCurLength, fLength, arrDirectionLengths(181) As Float,
	nSegm, nNode, nItem As Integer

OnError GoTo ErrorOccured

OBJDirectionMedian = -1

	Do Case ObjectInfo(oInput, OBJ_INFO_TYPE)

		Case OBJ_TYPE_TEXT
			fDirection = -1

		Case OBJ_TYPE_LINE, OBJ_TYPE_ARC
			fDirection = OBJDirectionMedian(ConvertToPline(oInput))

		Case OBJ_TYPE_COLLECTION, OBJ_TYPE_MPOINT
			fDirection = -1

		Case OBJ_TYPE_ELLIPSE, OBJ_TYPE_RECT, OBJ_TYPE_ROUNDRECT
			fDirection = OBJDirectionMedian(ConvertToRegion(oInput))

		Case OBJ_TYPE_PLINE, OBJ_TYPE_REGION

			For nSegm = 1 To ObjectInfo(oInput, OBJ_INFO_NPOLYGONS)
				fStartX = ObjectNodeX(oInput, nSegm, 1)
				fStartY = ObjectNodeY(oInput, nSegm, 1)
				For nNode = 2 To ObjectInfo(oInput, OBJ_INFO_NPOLYGONS + nSegm)
					fEndX 		= ObjectNodeX(oInput, nSegm, nNode)
					fEndY 		= ObjectNodeY(oInput, nSegm, nNode)
					fCurLength	= Distance(fStartX, fStartY, fEndX, fEndY, "m")

					If fCurLength > 0 Then
						If fStartX > fEndX Then
							If fStartY > fEndY Then
								fCurDirection 	= MATHGetDirection(fEndX, fEndY, fStartX, fStartY)
							Else
								fCurDirection 	= MATHGetDirection(fStartX, fStartY, fEndX, fEndY)
							End If
						ElseIf fStartY > fEndY Then
							If fStartX < fEndX Then
								fCurDirection 	= MATHGetDirection(fEndX, fEndY, fStartX, fStartY)
							Else
								fCurDirection 	= MATHGetDirection(fStartX, fStartY, fEndX, fEndY)
							End If
						Else
							fCurDirection 	= MATHGetDirection(fStartX, fStartY, fEndX, fEndY)
						End If

						nItem	= Round(fCurDirection, 1) + 1
						arrDirectionLengths(nItem) = arrDirectionLengths(nItem) + fCurLength
					End If

					fLength = fLength + fCurLength
					fStartX = fEndX
					fStartY = fEndY
				Next	'nNode
			Next	'nSegm

			For nItem = 1 To Ubound(arrDirectionLengths)
				fCurLength = fCurLength + arrDirectionLengths(nItem)
				If fCurLength > (fLength / 2) Then
					fDirection = (nItem - 1)
					Exit For
				End If
			Next

		Case Else
			fDirection = -1
	End Case

	OBJDirectionMedian = fDirection

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJDirectionMedian")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'	A point created along the input (poly)line
'	Only works for single segment polylines
'	Make sure to set the projected coordinate system to use before calling this function
'**********************************************************************************************''
Function OBJCartesianCreatePointAlong(	  ByVal oPolyline As Object	'The polyline to create the point along
								, ByVal fDistance As Float	'Distance along polyline, can also be negative
								, ByVal fOffset As Float		'Offset from polyline, negative is left, positive is right
								) As Object

Dim	oPoint As Object,
	fLength, fLengthTotal, fLengthSofar, fX, fY, fXNext, fYNext,fXMid, fYMid, fXDiff, fYDiff As Float,
    	nNumNodes, nNode As Integer

OnError GoTo ErrorOccured

	OBJCartesianCreatePointAlong = CreatePoint(0.00, 0.00)
	OBJCartesianCreatePointAlong = Centroid(oPolyline)
	OBJCartesianCreatePointAlong = CreatePoint(ObjectNodeX(oPolyline, 1, 1), ObjectNodeY(oPolyline, 1, 1))

	If ObjectInfo(oPolyline, OBJ_INFO_TYPE) = OBJ_TYPE_LINE Then
		oPolyline = ConvertToPline(oPolyline)
 	End If

	If ObjectInfo(oPolyline, OBJ_INFO_TYPE) = OBJ_TYPE_PLINE Then
		If ObjectInfo(oPolyline, OBJ_INFO_NPOLYGONS) > 1 Then
			'**Only works for single segment polylines
			Exit Function
		End If

		nNumNodes		= ObjectInfo(oPolyline,OBJ_INFO_NPNTS)
		fLengthTotal	= CartesianObjectLen(oPolyline, "m")
		fLength		= 0
		fLengthSofar	= 0

		If fDistance < 0 Then
			fX 			= ObjectNodeX(oPolyline, 1, 2)
			fY			= ObjectNodeY(oPolyline, 1, 2)
			fXNext		= ObjectNodeX(oPolyline, 1, 1)
			fYNext		= ObjectNodeY(oPolyline, 1, 1)
'			Print "Option 1: CartesianDistance: " & FormatNumber$(fX) & " " & FormatNumber$(fY) & " | "  & FormatNumber$(fXNext) & " " & FormatNumber$(fYNext)
			fLength 		= CartesianDistance(fX, fY, fXNext, fYNext, "m")

			fDistance		= (-1 * fDistance) + fLength	'**Making it positive & adding the length of the first segment
			fOffset		= -1 * fOffset		'**Mirroring the offset as we mirror the line too

'			Print "Option 1: Distance: " & FormatNumber$(fDistance) & " m., Offset: " & FormatNumber$(fOffset) & " m."
			fXMid	= fX + (fDistance - fLengthSofar) * (fXNext-fX) / Sqr((fX-fXNext)^2 + (fY-fYNext) ^ 2)
			fYMid	= fY + (fDistance - fLengthSofar) * (fYNext-fY) / Sqr((fX-fXNext)^2 + (fY-fYNext) ^ 2)

		ElseIf fDistance > fLengthTotal Then
			fLengthSofar	= fLengthTotal
			fX 			= ObjectNodeX(oPolyline, 1, (nNumNodes - 1))
			fY			= ObjectNodeY(oPolyline, 1, (nNumNodes - 1))
			fXNext		= ObjectNodeX(oPolyline, 1, nNumNodes)
			fYNext		= ObjectNodeY(oPolyline, 1, nNumNodes)
'			Print "Option 2: CartesianDistance: " & FormatNumber$(fX) & " " & FormatNumber$(fY) & " | "  & FormatNumber$(fXNext) & " " & FormatNumber$(fYNext)
			fLength 		= CartesianDistance(fX, fY, fXNext, fYNext, "m")

			fDistance		= fDistance + fLength	'**Adding the length of the last segment

'			Print "Option 1: Distance: " & FormatNumber$(fDistance) & " m., Offset: " & FormatNumber$(fOffset) & " m."
			fXMid	= fX + (fDistance - fLengthSofar) * (fXNext-fX) / Sqr((fX-fXNext)^2 + (fY-fYNext) ^ 2)
			fYMid	= fY + (fDistance - fLengthSofar) * (fYNext-fY) / Sqr((fX-fXNext)^2 + (fY-fYNext) ^ 2)

		ElseIf fDistance = 0 Then
			fLengthSofar	= 0
			fXMid 		= ObjectNodeX(oPolyline, 1, 1)
			fYMid		= ObjectNodeY(oPolyline, 1, 1)

		Else
			fX 			= ObjectNodeX(oPolyline, 1, 1)
			fY			= ObjectNodeY(oPolyline, 1, 1)

			For nNode = 2 To nNumNodes
				fXNext	= ObjectNodeX(oPolyline, 1, nNode)
				fYNext	= ObjectNodeY(oPolyline, 1, nNode)
				fLength	= CartesianDistance(fX, fY, fXNext, fYNext, "m")
				If (fLengthSofar + fLength) >= fDistance Then
					Exit For
				End If
				fLengthSofar = fLengthSofar + fLength
				fX	= fXNext
				fY	= fYNext
			Next	'nNode

'			Print "Option 3: Distance: " & FormatNumber$(fDistance) & " m., Offset: " & FormatNumber$(fOffset) & " m."
			fXMid	= fX + (fDistance - fLengthSofar) * (fXNext-fX) / Sqr((fX-fXNext)^2 + (fY-fYNext) ^ 2)
			fYMid	= fY + (fDistance - fLengthSofar) * (fYNext-fY) / Sqr((fX-fXNext)^2 + (fY-fYNext) ^ 2)

		End If

		If fOffset = 0 Then
			oPoint = CreatePoint(fXMid,fYMid)
		Else
			fXDiff	= (fY-fYMid) / Sqr((fY-fYMid) ^ 2 + (fX-fXMid) ^ 2) * Abs(fOffset)
			fYDiff	= (fXMid-fX) / Sqr((fY-fYMid) ^ 2 + (fX-fXMid) ^ 2) * Abs(fOffset)
			If fOffset < 0 Then
				'**Left side
				oPoint	= CreatePoint(fXMid + fXDiff, fYMid + fYDiff)
			Else
				'**Right Side
				oPoint	= CreatePoint(fXMid - fXDiff, fYMid - fYDiff)
			End If
		End If
	End If

	OBJCartesianCreatePointAlong = oPoint

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJCartesianCreatePointAlong")
	Call ERRPrint()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJCombineFromTable(	  ByVal sTab As String
						, ByVal sCol As String
						, ByVal sID As String
						) As Object

Dim	oCombined As Object,
	sCmd As String

OnError GoTo ErrorOccured

	sCmd = "Select * From " & sTab
	If sCol Then
		If ColumnInfo(sTab, sCol, COL_INFO_TYPE) = COL_TYPE_CHAR Then
			sCmd = sCmd & " Where " & sCol & " = " & Chr$(34) & sID & Chr$(34)
		Else
			sCmd = sCmd & " Where " & sCol & " = " & sID
		End If
	End If


	If SystemInfo(SYS_INFO_MIVERSION) >= 1700 Then
		sCmd = sCmd
			& " Into __TO__COMBINE NoSelect Hide"
	Else
		sCmd = sCmd
			& " Into __TO__COMBINE NoSelect"
	End If

'	Print sCmd
	Run Command sCmd

	Set Progressbars Off
	Create Object As Union
		From __TO__COMBINE
		Into Variable oCombined
'	Print "Area: " & CartesianArea(oCombined, "sq m")
	Set Progressbars On

	Close Table __TO__COMBINE

	OBJCombineFromTable = oCombined

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJCombineFromTable")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJCreateTrapez(	  ByVal oStartPoint As Object
						, ByVal fDirection As Float
						, ByVal fLength As Float
						, ByVal fWidthAtStart As Float
						, ByVal fWidthAtEnd As Float
						, ByVal bCreateMidpoint As Logical
						, ByVal nCalculationMethod As Integer		'CALC_METHOD_CARTESIAN / CALC_METHOD_SPERICAL
						) As Object

Dim	oPoint, oGeometry As Object,
	fWidth, fDirection1, fDirection2 As Float

OnError GoTo ErrorOccured

OBJCreateTrapez = oStartPoint

	fDirection1	= fDirection - 90
	If fDirection1 < 0 Then
		fDirection1 = fDirection1 + 360
	End If
	fDirection2	= fDirection + 90
	If fDirection2 > 360 Then
		fDirection2 = fDirection2 - 360
	End If

	Create Pline
		Into Variable oGeometry
		0

	If fWidthAtStart = 0 Then
		Alter Object oGeometry
			Node Add (CentroidX(oStartPoint), CentroidY(oStartPoint))
	Else
		fWidth	= fWidthAtStart / 2

		If nCalculationMethod = CALC_METHOD_CARTESIAN Then
			oPoint	= CartesianOffset(oStartPoint, fDirection1, fWidth, "m")
		Else
			oPoint	= Offset(oStartPoint, fDirection1, fWidth, "m")
		End If
		Alter Object oGeometry
			Node Add (CentroidX(oPoint), CentroidY(oPoint))

		If bCreateMidpoint Then
			Alter Object oGeometry
				Node Add (CentroidX(oStartPoint), CentroidY(oStartPoint))
		End If

		If nCalculationMethod = CALC_METHOD_CARTESIAN Then
			oPoint	= CartesianOffset(oStartPoint, fDirection2, fWidth, "m")
		Else
			oPoint	= Offset(oStartPoint, fDirection2, fWidth, "m")
		End If
		Alter Object oGeometry
			Node Add (CentroidX(oPoint), CentroidY(oPoint))
	End If

	If nCalculationMethod = CALC_METHOD_CARTESIAN Then
		oStartPoint	= CartesianOffset(oStartPoint, fDirection, fLength, "m")
	Else
		oStartPoint	= Offset(oStartPoint, fDirection, fLength, "m")
	End If

	If fWidthAtEnd = 0 Then
		Alter Object oGeometry
			Node Add (CentroidX(oStartPoint), CentroidY(oStartPoint))
	Else
		fWidth	= fWidthAtEnd / 2

		If nCalculationMethod = CALC_METHOD_CARTESIAN Then
			oPoint	= CartesianOffset(oStartPoint, fDirection2, fWidth, "m")
		Else
			oPoint	= Offset(oStartPoint, fDirection2, fWidth, "m")
		End If
		Alter Object oGeometry
			Node Add (CentroidX(oPoint), CentroidY(oPoint))

		If bCreateMidpoint Then
			Alter Object oGeometry
				Node Add (CentroidX(oStartPoint), CentroidY(oStartPoint))
		End If

		If nCalculationMethod = CALC_METHOD_CARTESIAN Then
			oPoint	= CartesianOffset(oStartPoint, fDirection1, fWidth, "m")
		Else
			oPoint	= Offset(oStartPoint, fDirection1, fWidth, "m")
		End If
		Alter Object oGeometry
			Node Add (CentroidX(oPoint), CentroidY(oPoint))
	End If

	OBJCreateTrapez = ConvertToRegion(oGeometry)

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJCreateTrapez")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJCreateTriangle(	  ByVal oStartPoint As Object			'Start point using current session coordinate system
						, ByVal fDirection As Float			'Direction from the start point
						, ByVal fLength As Float				'Width at starting point, if zero geometry will be a triangle
						, ByVal fWidthAtEnd As Float			'Width at end point
						, ByVal bCreateMidpoint As Logical		'Determines if the triangle should have a node at the mid point on the end side
						, ByVal nCalculationMethod As Integer	'CALC_METHOD_CARTESIAN / CALC_METHOD_SPERICAL: Use Offset or CartesianOffset
						) As Object

OnError GoTo ErrorOccured

OBJCreateTriangle = OBJCreateTrapez(oStartPoint, fDirection, fLength, 0, fWidthAtEnd, bCreateMidpoint, nCalculationMethod)

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJCreateTriangle")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes
'	Creates an Arraw Head pointing from the start of the line towards the end of the line
'	The Point of the Arrow Head is at the end of the line
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJCartesianCreateArrowHead(	  ByVal oPline As Object
								, ByVal nArrowType As Integer		'1: Pointy, 2: Flat, 3: Rounded
								, ByVal fWidth As Float			'in meters
								, ByVal fLength As Float			'in meters
								, ByVal nResolution As Integer	'Only used for rounded arrow heads
								) As Object

Dim	oArrowHead, oPoint As Object

OnError GoTo ErrorOccured

OBJCartesianCreateArrowHead = oPline

	oPline	= ConvertToPline(oPline)
	Create Pline
		Into Variable oArrowHead
		0

	Do Case nArrowType
		Case OBJ_ARROW_END_TYPE_ARROW	'Pointy
			'Print "OBJCartesianCreateArrowHead: Pointy"
			Alter Object oArrowHead
				Node Add (ObjectNodeX(oPline, 1, 2), ObjectNodeY(oPline, 1, 2))

			fLength	= CartesianObjectLen(oPline, "m") - fLength
			oPoint	= OBJCartesianCreatePointAlong(oPline, fLength, fWidth)
			Alter Object oArrowHead
				Node Add (CentroidX(oPoint), CentroidY(oPoint))

			oPoint	= OBJCartesianCreatePointAlong(oPline, fLength, -1 * fWidth)
			Alter Object oArrowHead
				Node Add (CentroidX(oPoint), CentroidY(oPoint))

			oArrowHead	= ConvertToRegion(oArrowHead)

		Case OBJ_ARROW_END_TYPE_FLAT	'Flat
			'Print "OBJCartesianCreateArrowHead: Flat"
			oPoint	= OBJCartesianCreatePointAlong(oPline, CartesianObjectLen(oPline, "m"), fWidth)
			Alter Object oArrowHead
				Node Add (CentroidX(oPoint), CentroidY(oPoint))

			oPoint	= OBJCartesianCreatePointAlong(oPline, CartesianObjectLen(oPline, "m"), -1 * fWidth)
			Alter Object oArrowHead
				Node Add (CentroidX(oPoint), CentroidY(oPoint))

			fLength	= CartesianObjectLen(oPline, "m") - fLength
			oPoint	= OBJCartesianCreatePointAlong(oPline, fLength, -1 * fWidth)
			Alter Object oArrowHead
				Node Add (CentroidX(oPoint), CentroidY(oPoint))

			oPoint	= OBJCartesianCreatePointAlong(oPline, fLength, fWidth)
			Alter Object oArrowHead
				Node Add (CentroidX(oPoint), CentroidY(oPoint))

			oArrowHead	= ConvertToRegion(oArrowHead)

		Case OBJ_ARROW_END_TYPE_ROUNDED	'Rounded
			'Print "OBJCartesianCreateArrowHead: Rounded"
			oPoint		= CreatePoint(ObjectNodeX(oPline, 1, 1), ObjectNodeY(oPline, 1, 1))
			oArrowHead	= CartesianBuffer(oPoint, nResolution, fWidth, "m")

	End Case

	OBJCartesianCreateArrowHead = oArrowHead

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJCartesianCreateArrowHead")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJCreatePlineFromPoints(   ByVal oPoint1 As Object
							, ByVal oPoint2 As Object
							) As Object

Dim	oPline As Object

OnError GoTo ErrorOccured

OBJCreatePlineFromPoints = oPoint1

	Create Pline
		Into Variable oPline
		0
	Alter Object oPline
		Node Add Position 1, 1 (CentroidX(oPoint1), CentroidY(oPoint1))
	Alter Object oPline
		Node Add Position 1, 2 (CentroidX(oPoint2), CentroidY(oPoint2))

	OBJCreatePlineFromPoints = oPline

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJCreatePlineFromPoints")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJPlineAddNode(  ByVal oPline As Object
					, ByVal oPoint As Object
					) As Object

OnError GoTo ErrorOccured

OBJPlineAddNode = oPline

	Alter Object oPline
		Node
		Add ( CentroidX(oPoint), CentroidY(oPoint) )

	OBJPlineAddNode = oPline

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJPlineAddNode")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJCreateAnnulus( ByVal oCenter As Object
					, ByVal fDirection As Float
					, ByVal fRadiusInner As Float	'meters
					, ByVal fRadiusOuter As Float	'meters
					, ByVal fAngleWidth As Float
					, ByVal nResolution As Integer
					, ByVal nCalculationMethod As Integer		'CALC_METHOD_CARTESIAN / CALC_METHOD_SPERICAL
					) As Object

Dim	oPoint, oCutter, oAnnulus, oCircleInner As Object,
	fCutterDistance, fAngleHalf, fAngleQuarter As Float

OnError GoTo ErrorOccured

OBJCreateAnnulus = oCenter

	fCutterDistance	= fRadiusOuter * 3
	fAngleHalf		= fAngleWidth / 2
	fAngleQuarter		= fAngleWidth / 4

	Create Pline
		Into Variable oCutter
		1
		( CentroidX(oCenter), CentroidY(oCenter) )

	If nCalculationMethod = CALC_METHOD_SPERICAL Then
		oPoint	= SphericalOffSet(oCenter, (fDirection - fAngleHalf), fCutterDistance, "m")
		oCutter	= OBJPlineAddNode(oCutter, oPoint)

		oPoint	= SphericalOffSet(oCenter, (fDirection - fAngleQuarter), fCutterDistance, "m")
		oCutter	= OBJPlineAddNode(oCutter, oPoint)

		oPoint	= SphericalOffSet(oCenter, fDirection, fCutterDistance, "m")
		oCutter	= OBJPlineAddNode(oCutter, oPoint)

		oPoint	= SphericalOffSet(oCenter, (fDirection + fAngleQuarter), fCutterDistance, "m")
		oCutter	= OBJPlineAddNode(oCutter, oPoint)

		oPoint	= SphericalOffSet(oCenter, (fDirection + fAngleHalf), fCutterDistance, "m")
		oCutter	= OBJPlineAddNode(oCutter, oPoint)
	Else
		oPoint	= CartesianOffSet(oCenter, (fDirection - fAngleHalf), fCutterDistance, "m")
		oCutter	= OBJPlineAddNode(oCutter, oPoint)

		oPoint	= CartesianOffSet(oCenter, (fDirection - fAngleQuarter), fCutterDistance, "m")
		oCutter	= OBJPlineAddNode(oCutter, oPoint)

		oPoint	= CartesianOffSet(oCenter, fDirection, fCutterDistance, "m")
		oCutter	= OBJPlineAddNode(oCutter, oPoint)

		oPoint	= CartesianOffSet(oCenter, (fDirection + fAngleQuarter), fCutterDistance, "m")
		oCutter	= OBJPlineAddNode(oCutter, oPoint)

		oPoint	= CartesianOffSet(oCenter, (fDirection + fAngleHalf), fCutterDistance, "m")
		oCutter	= OBJPlineAddNode(oCutter, oPoint)
	End If

	oCutter	= ConvertToRegion(oCutter)

	If nCalculationMethod = CALC_METHOD_SPERICAL Then
		oAnnulus	= Buffer(oCenter, nResolution, fRadiusOuter, "m")
	Else
		oAnnulus	= CartesianBuffer(oCenter, nResolution, fRadiusOuter, "m")
	End If

	If fRadiusInner > 0 Then
		If nCalculationMethod = CALC_METHOD_SPERICAL Then
			oCircleInner	= Buffer(oCenter, nResolution, fRadiusInner, "m")
		Else
			oCircleInner	= CartesianBuffer(oCenter, nResolution, fRadiusInner, "m")
		End If
		oAnnulus = Erase(oAnnulus, oCircleInner)
	End If

	oAnnulus = Overlap(oAnnulus, oCutter)

	OBJCreateAnnulus = oAnnulus

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJCreateAnnulus")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJCreateCircularSector(	  ByVal oCenter As Object
							, ByVal fDirection As Float
							, ByVal fRadius As Float				'meters
							, ByVal fAngleWidth As Float
							, ByVal nResolution As Integer
							, ByVal nCalculationMethod As Integer	'CALC_METHOD_CARTESIAN / CALC_METHOD_SPERICAL
							) As Object

OnError GoTo ErrorOccured

	OBJCreateCircularSector = OBJCreateAnnulus(oCenter, fDirection, 0, fRadius, fAngleWidth, nResolution, nCalculationMethod)

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJCreateCircularSector")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function OBJCartesianCreateArrow(	  ByVal oInput As Object				'Input polyline to draw arrow based on
							, ByVal fNodeDensity As Float			'Density for removing duplicate points on input line, 0 for not removing
							, ByVal nBufferResolution As Integer	'Buffer resolution for arrow line
							, ByVal fArrowWidth As Float			'Width of arrow, in meters
							, ByVal nArrowHeadType As Integer		'Arrow Head Type, 1: OBJ_ARROW_END_TYPE_ROUNDED, 2: OBJ_ARROW_END_TYPE_FLAT, 3: OBJ_ARROW_END_TYPE_ARROW
							, ByVal fArrowHeadLengthPct As Float	'Length of Arrow Head in % of arrow width, given as a decimal value where 1.0 is 100%, typical value is around 2.0, for flat and rounded set it to 1.0
							, ByVal fArrowHeadWidthPct As Float	'Width of Arrow Head in % of arrow width, given as a decimal value where 1.0 is 100%, typical value is around 2.0, for flat and rounded set it to 1.0
							, ByVal nArrowTailType As Integer		'Arrow Tail Type, 1: OBJ_ARROW_END_TYPE_ROUNDED, 2: OBJ_ARROW_END_TYPE_FLAT, 3: OBJ_ARROW_END_TYPE_ARROW
							, ByVal fArrowTailLengthPct As Float	'Length of Arrow Tail in % of arrow width, given as a decimal value where 1.0 is 100%, typical value is around 2.0, for flat and rounded set it to 1.0
							, ByVal fArrowTailWidthPct As Float	'Width of Arrow Tail in % of arrow width, given as a decimal value where 1.0 is 100%, typical value is around 2.0, for flat and rounded set it to 1.0
							) As Object

Dim	oLineStart, oLineEnd, oBuffer, oArrow, oArrowLine, oArrowTail, oArrowHead, oPoint As Object,
	fStartX, fStartY, fEndX, fEndY As Float,
	nNumNodes As Integer

OnError GoTo ErrorOccured

OBJCartesianCreateArrow = oInput

'	Print "Arrow Width, m: " & fArrowWidth
'	Print "Arrow Head Length: " & (fArrowHeadLengthPct * 100) & "% -> " & (fArrowHeadLengthPct * fArrowWidth) & " m"
'	Print "Arrow Head Width: " & (fArrowHeadWidthPct * 100) & "% -> " & (fArrowHeadWidthPct * fArrowWidth) & " m"
'	Print "Arrow Tail Length: " & (fArrowTailLengthPct * 100) & "% -> " & (fArrowTailLengthPct * fArrowWidth) & " m"
'	Print "Arrow Tail Width: " & (fArrowTailWidthPct * 100) & "% -> " & (fArrowTailWidthPct * fArrowWidth) & " m"

	If fNodeDensity = 0 Then
		oArrowLine	= oInput
	Else
		oArrowLine 	= OBJRemoveDuplicateNodes(oInput, fNodeDensity)	'meters
	End If

	'**Creating Arrow Head at the end of the line
	nNumNodes		= ObjectInfo(oArrowLine, OBJ_INFO_NPNTS)
	fEndX		= ObjectNodeX(oArrowLine, 1, nNumNodes)
	fEndY		= ObjectNodeY(oArrowLine, 1, nNumNodes)

	oBuffer		= CartesianBuffer(CreatePoint(fEndX, fEndY), nBufferResolution, fArrowHeadLengthPct * fArrowWidth, "m")
	If oArrowLine Entirely Within oBuffer Then
		'**Do nothing
	Else
		oArrowLine	= Erase(oArrowLine, oBuffer)
	End If
	nNumNodes		= ObjectInfo(oArrowLine, OBJ_INFO_NPNTS)

	Create Pline
		Into Variable oLineEnd
		0
	Alter Object oLineEnd
		Node Add Position 1, 1 (ObjectNodeX(oArrowLine, 1, nNumNodes), ObjectNodeY(oArrowLine, 1, nNumNodes))
	Alter Object oLineEnd
		Node Add Position 1, 2 (fEndX, fEndY)

'OBJ_ARROW_END_TYPE_ROUNDED		1
'OBJ_ARROW_END_TYPE_FLAT			2
'OBJ_ARROW_END_TYPE_ARROW		3

	oArrowHead	= OBJCartesianCreateArrowHead(oLineEnd, nArrowHeadType, fArrowHeadWidthPct * fArrowWidth, fArrowHeadLengthPct * fArrowWidth, nBufferResolution)
	If nArrowHeadType In (OBJ_ARROW_END_TYPE_ARROW, OBJ_ARROW_END_TYPE_FLAT) Then
		If oArrowLine Entirely Within oArrowHead Then
			'**Do nothing
		Else
			oArrowLine	= Erase(oArrowLine, oArrowHead)
		End If
	End If

	'**Creating Arrow Tail at the start of the line
	fStartX		= ObjectNodeX(oArrowLine, 1, 1)
	fStartY		= ObjectNodeY(oArrowLine, 1, 1)

	oBuffer		= CartesianBuffer(CreatePoint(fStartX, fStartY), nBufferResolution, fArrowTailLengthPct * fArrowWidth, "m")
	If oArrowLine Entirely Within oBuffer Then
		'**Do nothing
	Else
		oArrowLine	= Erase(oArrowLine, oBuffer)
	End If

	Create Pline
		Into Variable oLineStart
		0
	Alter Object oLineStart
		Node Add Position 1, 1 (ObjectNodeX(oArrowLine, 1, 1), ObjectNodeY(oArrowLine, 1, 1))
	Alter Object oLineStart
		Node Add Position 1, 2 (fStartX, fStartY)

	oArrowTail	= OBJCartesianCreateArrowHead(oLineStart, nArrowTailType, fArrowTailWidthPct * fArrowWidth, fArrowTailLengthPct * fArrowWidth, nBufferResolution)
	If nArrowTailType in (OBJ_ARROW_END_TYPE_FLAT, OBJ_ARROW_END_TYPE_ARROW) Then
		If oArrowLine Entirely Within oArrowTail Then
			'**Do nothing
		Else
			oArrowLine	= Erase(oArrowLine, oArrowTail)
		End If
	End If

	oArrow		= CartesianBuffer(oArrowLine, nBufferResolution, fArrowWidth, "m")

	oArrow		= Combine(oArrow, oArrowHead)
	oArrow		= Combine(oArrow, oArrowTail)

OBJCartesianCreateArrow = oArrow

	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "OBJCartesianCreateArrow")
	Call ERRPrint()

End Function